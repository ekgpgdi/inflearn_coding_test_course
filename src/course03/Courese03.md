# 슬라이딩 윈도우와 투 포인터 알고리즘 (Sliding Window & Two Pointer Algorithm)

슬라이딩 윈도우와 투 포인터 알고리즘은 **배열이나 리스트**에서 **연속된 부분 배열** 또는 **부분 문자열**을 효율적으로 처리하기 위한 알고리즘 기법입니다. 두 알고리즘은 모두 **포인터**를 사용하여 **범위를 탐색**하는 방식입니다. 슬라이딩 윈도우는 **고정된 크기**의 윈도우를, 투 포인터는 **가변적인 크기**의 윈도우를 사용합니다.

## 기본 아이디어

### 슬라이딩 윈도우
- 주어진 문제에 대해 **고정된 크기**의 윈도우를 사용하여 **배열이나 문자열**을 탐색합니다.
- 윈도우의 크기는 처음에 고정되며, 이를 **슬라이딩**하면서 결과를 계산합니다.
- 주로 **연속된 부분 배열**이나 **부분 문자열**을 다룰 때 사용됩니다.

### 투 포인터
- 두 개의 포인터(`lt`, `rt`)를 사용하여 **배열이나 문자열**의 부분을 탐색합니다.
- **윈도우 크기**는 **동적으로** 조정되며, 조건을 만족하는 구간을 찾을 때 사용됩니다.
- `lt`는 윈도우의 **시작**을, `rt`는 **끝**을 나타내며, 두 포인터를 활용해 범위를 조절합니다.

## 두 알고리즘의 차이점

| 알고리즘          | 슬라이딩 윈도우                                   | 투 포인터                                      |
|-------------------|--------------------------------------------------|------------------------------------------------|
| **윈도우 크기**    | 고정된 크기                                       | 가변적인 크기                                  |
| **포인터**         | 하나의 포인터를 이동시키며 범위를 확장 (또는 축소) | 두 개의 포인터를 사용하여 동적으로 범위 조정   |
| **주요 용도**      | 고정 크기의 부분 배열을 처리할 때               | 부분 배열 크기를 조정하며 조건을 만족하는 경우 |

---

## 슬라이딩 윈도우 예시: 연속된 k개의 숫자 합 구하기

배열에서 연속된 `k`개의 숫자 합을 구하는 문제는 **슬라이딩 윈도우**로 해결할 수 있습니다. 윈도우 크기는 `k`로 고정되며, 윈도우를 오른쪽으로 한 칸씩 슬라이딩합니다.

### 코드 구현

```java
public int maxSum(int[] arr, int k) {
    int n = arr.length;
    int maxSum = 0;
    int windowSum = 0;

    // 첫 번째 윈도우를 계산
    for (int i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    maxSum = windowSum;

    // 슬라이딩 윈도우로 나머지 부분 계산
    for (int i = k; i < n; i++) {
        windowSum = windowSum - arr[i - k] + arr[i];
        maxSum = Math.max(maxSum, windowSum);
    }

    return maxSum;
}
```

### 동작 설명
1. 처음에는 배열의 첫 번째 k개의 값을 더하여 첫 번째 윈도우의 합을 구합니다. 
2. 이후 윈도우를 오른쪽으로 한 칸씩 슬라이딩하면서 windowSum을 갱신합니다. 
   * 슬라이딩할 때, 이전 윈도우의 첫 번째 값을 빼고 새로운 값을 더하여 윈도우의 합을 계산합니다. 
3. maxSum을 계산하면서 최댓값을 찾습니다.

---

## 투 포인터 예시: 연속된 부분 배열의 합이 k인 경우
투 포인터를 사용하여 연속된 부분 배열의 합이 k인 경우의 수를 구하는 문제를 해결할 수 있습니다. 이때 윈도우의 크기는 동적으로 조정됩니다.

### 코드 구현 
```java 
public int solution(int[] dataSet, int k) {
    int answer = 0;
    int sum = 0;
    int lt = 0;  // 왼쪽 포인터

    // rt는 오른쪽 포인터로 배열을 끝까지 순회합니다.
    for (int rt = 0; rt < dataSet.length; rt++) {
        sum += dataSet[rt];  // rt가 가리키는 값을 더함
        
        // sum이 k일 때, 카운트를 증가시킴
        if (sum == k) {
            answer++;
        }

        // sum이 k 이상일 때, lt를 증가시켜 윈도우 크기를 축소
        while (sum >= k) {
            sum -= dataSet[lt++];  // lt를 이동시키며 sum을 축소

            if (sum == k) {
                answer++;
            }
        }
    }

    return answer;  // 결과 반환
}
```

### 동작 설명
1. rt 포인터는 배열을 끝까지 순회하면서 부분 배열의 합 sum을 갱신합니다. 
2. sum == k일 때마다 answer를 증가시킵니다. 
3. sum이 k 이상이 되면, lt 포인터를 이동시켜 부분 배열의 크기를 축소하면서 sum을 갱신합니다. 이때 sum == k가 될 경우 추가적으로 answer를 증가시킵니다.

---

## 요약

- **슬라이딩 윈도우**: 고정된 크기 윈도우를 사용하여 연속된 부분 배열의 합 등을 구할 때 유용합니다.
- **투 포인터**: 두 포인터(`lt`, `rt`)를 사용하여 윈도우의 크기를 동적으로 조정하면서 문제를 해결하는 방식입니다. 윈도우 크기를 자유롭게 변경하며 범위를 탐색할 수 있습니다.